<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jason Bryer on Jason Bryer</title>
    <link>/</link>
    <description>Recent content in Jason Bryer on Jason Bryer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2020</copyright>
    <lastBuildDate>Wed, 31 Jan 2018 00:00:00 -0500</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Framework for Shiny Apps in R Packages</title>
      <link>/post/2021-02-12-shiny_apps_in_r_packages/</link>
      <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021-02-12-shiny_apps_in_r_packages/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;&lt;strong&gt;TL;DR:&lt;/strong&gt; You can test this approach using this &lt;a href=&#34;https://gist.github.com/jbryer/fc8834279189196ead710e89b56d7f88&#34;&gt;Github Gist&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shiny.rstudio.com&#34;&gt;R Shiny Apps&lt;/a&gt; have become a popular way of creating web applications in R. There are many ways of running Shiny Apps including locally in &lt;a href=&#34;https://rstudio.com/products/rstudio/&#34;&gt;RStudio&lt;/a&gt;, on &lt;a href=&#34;http://www.shinyapps.io/&#34;&gt;Shinyapps.io&lt;/a&gt; or &lt;a href=&#34;https://www.rstudio.com/products/shiny/shiny-server/&#34;&gt;installing the server software&lt;/a&gt; on your own host. I have been increasingly using Shiny apps as a way to demonstrate and interact with R Packages, especially packages I write for teaching purposes. Adding a Shiny app to an R package is relatively easy. In my use cases, I first put the application files (&lt;code&gt;server.R&lt;/code&gt;, &lt;code&gt;ui.R&lt;/code&gt;, and &lt;code&gt;global.R&lt;/code&gt;) in the &lt;code&gt;inst/shiny&lt;/code&gt; directory of my R package. I can then write a package function to run the Shiny app from the installed package directory using a function like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#&amp;#39; My Shiny App
#&amp;#39; @export
my_shiny_app &amp;lt;- function() {
    shiny::runApp(appDir = system.file(&amp;#39;shiny&amp;#39;, package=&amp;#39;MY_PACKAGE_NAME&amp;#39;))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works very well when the entire app is self-contained. However, this does not work if you want to pass parameters to the Shiny app. In my situation, I want to be able to pass different data frames that I can interact with, but still have the Shiny app work if not parameters are passed. The first step to get this to work is to convert the &lt;code&gt;server.R&lt;/code&gt; and &lt;code&gt;ui.R&lt;/code&gt; scripts to functions within the R package. The code is largely the same, but instead of calling the functions we are going to assign them to &lt;code&gt;shiny_server&lt;/code&gt; and &lt;code&gt;shiny_ui&lt;/code&gt;, respectively. I have also included some minimal &lt;a href=&#34;https://github.com/r-lib/roxygen2&#34;&gt;roxygen2&lt;/a&gt; documentation. In particular, the functions need to be in the package’s export file.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#&amp;#39; The Shiny App Server.
#&amp;#39; @param input input set by Shiny.
#&amp;#39; @param output output set by Shiny.
#&amp;#39; @param session session set by Shiny.
#&amp;#39; @export
shiny_server &amp;lt;- function(input, output, session) {
    if(!exists(&amp;#39;thedata&amp;#39;, envir = parent.env(environment()), inherits = FALSE)) {
        message(&amp;#39;thedata not available, using default faithful...&amp;#39;)
        data(faithful, envir = environment())
        thedata &amp;lt;- faithful
    }

    output$environment &amp;lt;- renderPrint(
        print(ls(envir = parent.env(environment())))
    )

    output$thedata &amp;lt;- renderTable({
        return(thedata)
    })
}

#&amp;#39; The Shiny App UI.
#&amp;#39; @export
shiny_ui &amp;lt;- function() {
    fluidPage(
        titlePanel(&amp;#39;Shiny Parameter Test&amp;#39;),
        verbatimTextOutput(&amp;#39;environment&amp;#39;),
        tableOutput(&amp;#39;thedata&amp;#39;)
    )
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This Shiny App doesn’t do a lot. It has one user variable, &lt;code&gt;thedata&lt;/code&gt;, and the user interface includes the output of &lt;code&gt;ls&lt;/code&gt; (i.e. what is in the executing environment) and the contents of &lt;code&gt;thedata&lt;/code&gt; (presumed to be a data frame). The important feature here is the first five lines of the &lt;code&gt;shiny_server&lt;/code&gt;. I first check to see if &lt;code&gt;thedata&lt;/code&gt; exists using the &lt;code&gt;!exists(&#39;thedata&#39;, envir = parent.env(environment()), inherits = FALSE)&lt;/code&gt; command. In short, if &lt;code&gt;thedata&lt;/code&gt; is not present, I want to set it to a reasonable default value.&lt;/p&gt;
&lt;p&gt;When encapsulating the Shiny app in R scripts, using the &lt;code&gt;runApp&lt;/code&gt; function with the &lt;code&gt;appDir&lt;/code&gt; parameter is sufficient. In order to pass variables to the Shiny app, we need to control the environment the app is started in. Below, is a rewrite of the &lt;code&gt;my_shiny_app&lt;/code&gt; app. First, we create a new environment that will contain all of our parameters. Since specifying the parameter is optional, we use the &lt;code&gt;missing&lt;/code&gt; function to check to see if it has a value, and if so assign it to the new environment. We then set the environment to our server and ui functions the newly created environment that now contains our parameters. The rest is similar to creating Shiny apps in a single &lt;code&gt;app.R&lt;/code&gt; file; create the app with the &lt;code&gt;shinyApp&lt;/code&gt; function and start it with the &lt;code&gt;runApp&lt;/code&gt; function, but with the app instead of a directory.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_shiny_app &amp;lt;- function(thedata, ...) {
    shiny_env &amp;lt;- new.env()
    if(!missing(thedata)) {
        print(&amp;#39;Setting parameters&amp;#39;)
        assign(&amp;#39;thedata&amp;#39;, thedata, shiny_env)
    }
    environment(shiny_ui) &amp;lt;- shiny_env
    environment(shiny_server) &amp;lt;- shiny_env
    app &amp;lt;- shiny::shinyApp(
        ui = shiny_ui,
        server = shiny_server
    )
    runApp(app, ...)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now start the Shiny app with the &lt;code&gt;my_shiny_app()&lt;/code&gt; function call. In the first instance, no parameters are passed to the app so the &lt;code&gt;faithful&lt;/code&gt; data frame will be printed. The second and third calls will use the &lt;code&gt;iris&lt;/code&gt; and &lt;code&gt;mtcars&lt;/code&gt; data frames, respectively.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_shiny_app()
my_shiny_app(thedata = iris)
my_shiny_app(thedata = mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The one disadvantage of this approach is that it is more difficult to run the Shiny app outside the package and maintaining the app in two formats is inconvenient. To address this issue the &lt;code&gt;save_shiny_app&lt;/code&gt; function will save the server and ui functions in the package to a &lt;code&gt;server.R&lt;/code&gt; and &lt;code&gt;ui.R&lt;/code&gt; script files in the specified directory. Additionally, it will create a &lt;code&gt;global.R&lt;/code&gt; file that loads the &lt;code&gt;shiny&lt;/code&gt; package and any other required packages as specified in the &lt;code&gt;pkgs&lt;/code&gt; parameter.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#&amp;#39; Save the Shiny App to an app.R file.
#&amp;#39;
#&amp;#39; This function will create three files in the \code{out_dir}: \code{server.R},
#&amp;#39; \code{ui.R}, and \code{global.R}. The contents of \code{server.R} and
#&amp;#39; \code{ui.R} will be the source code of the \code{server_function} and
#&amp;#39; \code{ui_function}, respectively. The \code{global.R} file will only contain
#&amp;#39; \code{library} calls for \code{shiny} and any other packages specified in
#&amp;#39; the \code{pkgs} parameter.
#&amp;#39;
#&amp;#39; If \code{run_app = TRUE} the function will start the Shiny app once the
#&amp;#39; files are written. This is recommended to ensure all the necessary packages
#&amp;#39; are loaded for the Shiny app to run.
#&amp;#39;
#&amp;#39; @param ui_function the function for the UI.
#&amp;#39; @param server_function the function for the server.
#&amp;#39; @param pkgs any packages that need to be loaded for the app to work. At
#&amp;#39;        minimum the package containing the shiny app should be included.
#&amp;#39; @param out_dir the directory to save the shiny app files.
#&amp;#39; @param run_app whether to run the app once the files are saved.
save_shiny_app &amp;lt;- function(ui_function,
                           server_function,
                           pkgs,
                           out_dir = &amp;#39;shiny&amp;#39;,
                           run_app = interactive()) {
    server_txt &amp;lt;- capture.output(server_function)
    ui_txt &amp;lt;- capture.output(ui_function)
    # Remove the bytecode and environment info
    server_txt &amp;lt;- server_txt[1:(length(server_txt)-2)]
    ui_txt &amp;lt;- ui_txt[3:(length(ui_txt)-3)]
    # Fix the function assignment
    server_txt[1] &amp;lt;- &amp;#39;shinyServer(function(input, output, session)&amp;#39;
    server_txt[length(server_txt)] &amp;lt;- &amp;#39;})&amp;#39;
    global_txt &amp;lt;- c(&amp;quot;library(&amp;#39;shiny&amp;#39;)&amp;quot;)
    if(!missing(pkgs)) {
        global_txt &amp;lt;- c(global_txt, paste0(&amp;quot;library(&amp;#39;&amp;quot;, pkgs, &amp;quot;&amp;#39;)&amp;quot;))
    }
    # Save the shiny app files
    cat(server_txt, sep = &amp;#39;\n&amp;#39;, file = paste0(out_dir, &amp;#39;/server.R&amp;#39;))
    cat(ui_txt, sep = &amp;#39;\n&amp;#39;, file = paste0(out_dir, &amp;#39;/ui.R&amp;#39;))
    cat(global_txt, sep = &amp;#39;\n&amp;#39;, file = paste0(out_dir, &amp;#39;/global.R&amp;#39;))
    # Start the app
    if(run_app) {
        runApp(appDir = out_dir)
    }
}&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>brickset</title>
      <link>/project/brickset/</link>
      <pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/project/brickset/</guid>
      <description></description>
    </item>
    
    <item>
      <title>visualMLE</title>
      <link>/project/visualmle/</link>
      <pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/project/visualmle/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Editable DataTables for Shiny Applications</title>
      <link>/post/2018-22-26-dtedit/</link>
      <pubDate>Mon, 26 Nov 2018 21:13:14 -0500</pubDate>
      
      <guid>/post/2018-22-26-dtedit/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://rstudio.com&#34; target=&#34;_blank&#34;&gt;RStudio&lt;/a&gt; recently updated &lt;a href=&#34;https://shiny.rstudio.com&#34; target=&#34;_blank&#34;&gt;Shiny&lt;/a&gt; to allow for &lt;a href=&#34;https://blog.rstudio.com/2018/03/29/dt-0-4/&#34; target=&#34;_blank&#34;&gt;editable &lt;code&gt;DataTables&lt;/code&gt;&lt;/a&gt;. Their implementations allows for editing cells direclty with in the &lt;code&gt;DataTable&lt;/code&gt; view. This is fine for many advanced applications, however, for many applications more fine tuned control of what the user can edit is necessary. For example, you may want to only allow a subset of columns to be editable. Or you want to view a subset of columns in a spreadsheet view but allow other columns to be editable. The &lt;code&gt;DTedit&lt;/code&gt; package takes the editing out of the table view and instead presents the user with a &lt;a href=&#34;https://shiny.rstudio.com/articles/modal-dialogs.html&#34; target=&#34;_blank&#34;&gt;modal dialog&lt;/a&gt; for editing table contents (see screenshot below).&lt;/p&gt;

&lt;p&gt;To get started, use the &lt;code&gt;devtools&lt;/code&gt; package to install the latest development version of &lt;code&gt;DTedit&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;devtools::install_github(&#39;jbryer/DTedit&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;dtedit_demo&lt;/code&gt; will run a sample &lt;code&gt;shiny&lt;/code&gt; app with to editable data tables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DTedit::dtedit_demo()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jbryer/DTedit/master/inst/screens/dtedit_books_edit.png&#34; alt=&#34;DTedit Screen Shot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-dtedit&#34;&gt;Getting Started with &lt;code&gt;DTedit&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;You can download a simple shiny app using &lt;code&gt;DTedit&lt;/code&gt; &lt;a href=&#34;https://github.com/jbryer/DTedit/blob/master/inst/template/app.R&#34; target=&#34;_blank&#34;&gt;from Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are three steps to using &lt;code&gt;DTedit&lt;/code&gt; in your shiny application.&lt;/p&gt;

&lt;h4 id=&#34;1-define-callback-function-for-inserting-updating-and-deleting-data&#34;&gt;1. Define callback function for inserting, updating, and deleting data.&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;NOTE: These callback functions assume that &lt;code&gt;mydata&lt;/code&gt; is already defined somewhere outside the callback functions. See the &lt;a href=&#34;https://github.com/jbryer/DTedit/blob/master/inst/template/app.R&#34; target=&#34;_blank&#34;&gt;template&lt;/a&gt; for the complete example using &lt;code&gt;data.frames&lt;/code&gt;, or &lt;a href=&#34;https://github.com/jbryer/DTedit/tree/master/inst/shiny_demo&#34; target=&#34;_blank&#34;&gt;this demo&lt;/a&gt; for an example using &lt;code&gt;RSQLite&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my.insert.callback &amp;lt;- function(data, row) {
	mydata &amp;lt;- rbind(data, mydata)
	return(mydata)
}

my.update.callback &amp;lt;- function(data, olddata, row) {
	mydata[row,] &amp;lt;- data[1,]
	return(mydata)
}

my.delete.callback &amp;lt;- function(data, row) {
	mydata &amp;lt;- mydata[-row,]
	return(mydata)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typically these functions would interact with a database. As written here, the data would be lost between shiny sessions.&lt;/p&gt;

&lt;h4 id=&#34;2-create-the-dtedit-object-within-your-server-function&#34;&gt;2. Create the &lt;code&gt;dtedit&lt;/code&gt; object within your &lt;code&gt;server&lt;/code&gt; function.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;DTedit::dtedit(input, output,
	   name = &#39;mycontacts&#39;,
	   thedata = mydata,
	   edit.cols = c(&#39;name&#39;, &#39;email&#39;, &#39;useR&#39;, &#39;notes&#39;),
	   edit.label.cols = c(&#39;Name&#39;, &#39;Email Address&#39;, &#39;Are they an R user?&#39;, &#39;Additional notes&#39;),
	   input.types = c(notes=&#39;textAreaInput&#39;),
	   view.cols = c(&#39;name&#39;, &#39;email&#39;, &#39;useR&#39;),
	   callback.update = my.update.callback,
	   callback.insert = my.insert.callback,
	   callback.delete = my.delete.callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; are passed from the &lt;code&gt;server&lt;/code&gt; function. The &lt;code&gt;name&lt;/code&gt; parameter will define the name of the object available to the &lt;code&gt;uiOutput&lt;/code&gt;. The &lt;code&gt;thedata&lt;/code&gt; is a &lt;code&gt;data.frame&lt;/code&gt; for the initial view of the data table. This can be an empty (i.e. no rows) &lt;code&gt;data.frame&lt;/code&gt;. The structure of the &lt;code&gt;data.frame&lt;/code&gt; will define the inputs (e.g. &lt;code&gt;factor&lt;/code&gt;s will be drop down, &lt;code&gt;Date&lt;/code&gt; will use &lt;code&gt;dateInput&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;s will use &lt;code&gt;numericInput&lt;/code&gt;, etc.). There are many other parameters to custom the behavior of &lt;code&gt;dtedit&lt;/code&gt;, see &lt;code&gt;?dtedit&lt;/code&gt; for the full list.&lt;/p&gt;

&lt;h4 id=&#34;3-use-uioutput-in-your-ui-to-display-the-editable-data-table&#34;&gt;3. Use &lt;code&gt;uiOutput&lt;/code&gt; in your UI to display the editable data table.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;name&lt;/code&gt; you will pass to &lt;code&gt;uiOutput&lt;/code&gt; is the name you passed to the &lt;code&gt;dtedit&lt;/code&gt; created on the server side.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uiOutput(&#39;mycontacts&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>DAACS</title>
      <link>/project/daacs/</link>
      <pubDate>Wed, 31 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/project/daacs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>PBIS</title>
      <link>/project/pbis/</link>
      <pubDate>Wed, 31 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/project/pbis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Likert</title>
      <link>/project/likert/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/project/likert/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Introduction to Shiny</title>
      <link>/talk/2018-03-03-open_data_day/</link>
      <pubDate>Fri, 03 Mar 2017 00:00:00 -0500</pubDate>
      
      <guid>/talk/2018-03-03-open_data_day/</guid>
      <description>&lt;p&gt;I will be teaching a short Introduction to Shiny as part of the Open Data Day.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Open Data Day is a collection of local gatherings of open government advocates, developers, programmers, statisticians, and citizens who want to build things with and promote the use of open data through project hacking. The next Open Data Day is March 3, 2018. The event welcomes participants from all backgrounds, interests, and skill sets with a common enthusiasm for transparency. In addition to project hacking, participants can learn about some of the tools in the open data toolkit by joining in the training workshops.&lt;/p&gt;

&lt;p&gt;Event website: &lt;a href=&#34;http://opendataalbany.org/&#34; target=&#34;_blank&#34;&gt;http://opendataalbany.org/&lt;/a&gt;
Please RSVP Here: &lt;a href=&#34;https://opendatadayalbany.splashthat.com/&#34; target=&#34;_blank&#34;&gt;https://opendatadayalbany.splashthat.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PSA</title>
      <link>/project/psa/</link>
      <pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/project/psa/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Intro to Predictive Modeling</title>
      <link>/talk/2019-01-22-intro_to_predictive_modeling/</link>
      <pubDate>Sun, 01 Jan 2017 18:00:00 -0500</pubDate>
      
      <guid>/talk/2019-01-22-intro_to_predictive_modeling/</guid>
      <description>&lt;p&gt;This workshop will introduce the basic concepts and procedures for predictive modeling in R including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to evaluate the quality of predictive models using confusion matrices and ROC curves&lt;/li&gt;
&lt;li&gt;Classification and regression trees (CART methods)&lt;/li&gt;
&lt;li&gt;Ensemble methods (e.g. random forests, boosting, bagging)&lt;/li&gt;
&lt;li&gt;Discussion of issues and limitations of &amp;ldquo;black box&amp;rdquo; predictive modeling&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Intro to Propensity Score Analysis</title>
      <link>/talk/2019-03-28-intro_to_psa/</link>
      <pubDate>Sun, 01 Jan 2017 18:00:00 -0500</pubDate>
      
      <guid>/talk/2019-03-28-intro_to_psa/</guid>
      <description>&lt;p&gt;The use of propensity score methods (Rosenbaum &amp;amp; Rubin, 1983) for estimating causal effects in observational studies or certain kinds of quasi-experiments has been increasing in the social sciences (Thoemmes &amp;amp; Kim, 2011) and in medical research (Austin, 2008) in the last decade. Propensity score analysis (PSA) attempts to adjust selection bias that occurs due to the lack of randomization. Analysis is typically conducted in two phases where in phase I, the probability of placement in the treatment is estimated to identify matched pairs or clusters so that in phase II, comparisons on the dependent variable can be made between matched pairs or within clusters. R (R Core Team, 2012) is ideal for conducting PSA given its wide availability of the most current statistical methods vis-à-vis add-on packages as well as its superior graphics capabilities.&lt;/p&gt;

&lt;p&gt;This talk will provide a theoretical overview of propensity score methods as well as illustrations and discussion of PSA applications. Methods used in phase I of PSA (i.e. models or methods for estimating propensity scores) include logistic regression, classification trees, and matching. Discussions on appropriate comparisons and estimations of effect size and confidence intervals in phase II will also be covered. The use of graphics for diagnosing covariate balance as well as summarizing overall results will be emphasized.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Development Of The Large Scale Diagnostic Assessments Of College Skills</title>
      <link>/talk/2017-nera/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 -0500</pubDate>
      
      <guid>/talk/2017-nera/</guid>
      <description>&lt;p&gt;The Diagnostic Assessment and Achievement of College Skills (DAACS) is a technology-based, no-stakes
diagnostic assessment system on academic and non-academic skills, with fast, actionable feedback.
Development and piloting of these assessments at two online colleges is underway. Preliminary validity
and reliability evidence of these assessments are reported in this paper.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Jason Bryer, Excelsior College; Fusun Sahin, American Institutes for Research; Heidi Andrade, Angela Lui,
Diana Akhmedjanova, &amp;amp; David Franklin, University at Albany, SUNY&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Efficacy of the Diagnostic Assessment and Achievement of College Students on Multiple Success Indicators</title>
      <link>/talk/2019-aera-efficacy/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 -0500</pubDate>
      
      <guid>/talk/2019-aera-efficacy/</guid>
      <description>&lt;p&gt;The purpose of this study is to examine the effects and predictive power of the Diagnostic Assessment and Achievement of College Skills (DAACS) on student success. DAACS is a no-stakes, open-source, formative assessment tool designed to measure newly enrolled college students’ reading, writing, mathematics, and self-regulated learning (SRL) skills, and provide them with feedback and resources to enhance their functioning and success. A randomized control trial was performed at two online colleges (n = 17,687) to measure the effects in terms of academic achievement and credit acquisition. Predictive power of DAACS on student success were also examined. Results highlights the importance of using DAACS as a suite of assessments and supports, and not as isolated components.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Feedback on Writing for College Success: Machine Scoring of Essays on Self-Regulated Learning</title>
      <link>/talk/2018-sigwriting/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 -0500</pubDate>
      
      <guid>/talk/2018-sigwriting/</guid>
      <description>&lt;p&gt;This paper describes an ongoing project in which on-demand writing is used as part of a diagnostic evaluation of newly admitted college students. The authors will present preliminary evidence of the validity and reliability of human and machine scored essays and the usefulness of the feedback provided to students on their writing and their self-regulated learning. The purpose of the project, the Diagnostic Assessment and Achievement of College Skills (DAACS), is to develop a no-stakes diagnostic assessment designed to help students transition to college. Research suggests that mindset, self-regulation, and grit are predictors of college success (Duckworth, Peterson, Matthews, &amp;amp; Kelly, 2007; Zimmerman &amp;amp; Schunk, 2011). DAACS provides feedback to students about their strengths and weaknesses in mathematics, reading, and writing, as well as their self-regulated learning (SRL) skills, and links students to appropriate resources and support. For the writing assessment, students write an essay reflecting on the results of a survey about their self-regulated learning skills. In addition to encouraging students to reflect on their SRL, the writing assessment provides feedback about their writing and directs them towards relevant writing resources. Although this approach is similar to Directed Self-Placement (Gere et al., 2010), DAACS is not intended to be used for placement; rather, it helps students determine whether they need support as writers. The scoring rubric developed for this assessment includes five criteria: content, organization, paragraphs, sentences, and conventions. An open source, automated program called Lightside was trained with hundreds of essays scored by human raters. Preliminary results indicate acceptable agreement between human and machine scores, and high rates of student and advisor satisfaction. These results and implications for uses of machine scoring of essays will be presented.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Relationship Between Intraclass Correlation (ICC) and Percent Agreement</title>
      <link>/talk/2019-ncme-irrsim/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 -0500</pubDate>
      
      <guid>/talk/2019-ncme-irrsim/</guid>
      <description>&lt;p&gt;Inter-rater reliability (IRR) is a critical component of establishing the reliability of measures when more than one rater is necessary. There are numerous IRR statistics available to researchers including percent rater agreement, Cohen&amp;rsquo;s Kappa, and several types of intraclass correlations (ICC). Several methodologists suggest using ICC over percent rater agreement (Hallgren, 2012; Koo &amp;amp; Li, 2016; McGraw &amp;amp; Wong, 1996; Shrout &amp;amp; Fleiss, 1979). However, the literature provides little guidance on the interpretation of ICC results. This article explores the relationship between ICC and percent rater agreement using simulations. Results suggest that ICC and percent rater agreement are highly correlated ($R^2 &amp;gt; 0.9$) for most designs.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>
